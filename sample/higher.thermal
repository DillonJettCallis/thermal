

fun higherMath(op: fun { Int, Int -> Int }): Int {
  return op(2, 2);
}

def higherInput(dyn op: def { Int -> Int }): Int {
  return op(2);
}

def higherOutput(op: def { Int -> Int }): Int {
  return op(2);
}

fun returnHigher(num: Int): def { dyn Int -> Int } {
  return def { x => x + num };
}

def returnDynamicDef(dyn message: String): sig { -> Int } {
  var count = 0;
  return sig { =>
    log(message);
    count += 1;
    return count;
  }
}

fun superHigher(): def { dyn def { -> Int } -> Int } {
  return def { dyn someOperation: def { -> Int } =>
    return someOperation();
  }
}

struct SuperHigherControl {
  count: Int,
  trigger: sig { -> Unit },
}

def useSuperHigher(): SuperHigherControl {
  val action: def { dyn def { -> Int } -> Int } = superHigher();

  var base: Int = 0;
  var operator: def { -> Int } = def { => base / 5 };

  dyn resultOfAction: Int = action(operator);

  sig increment(): Unit {
    base = base + 1;

    if (Math::mod(base, 5) == 0) {
      operator = def { => base / 5 };
    } else {
      operator = def { => base + 3 };
    }
  }

  return SuperHigherControl {
    count: resultOfAction,
    trigger: increment
  };
}
